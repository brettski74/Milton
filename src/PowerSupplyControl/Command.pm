package PowerSupplyControl::Command;

use Getopt::Long qw(GetOptionsFromArray :config no_ignore_case bundling require_order);
use Hash::Merge;
use IO::File;
use Carp qw(croak);
use Scalar::Util qw(reftype);
use PowerSupplyControl::ValueTools qw(boolify checkMinimum timestamp);

=head1 NAME

PowerSupplyControl::Command - Base class for all commands

=head1 SYNOPSIS

  my $self = PowerSupplyControl::Command->new($config);

  return $self;
}

=head1 DESCRIPTION

This is the base class for all commands. To be loadable as commands, subclasses of PowerSupplyControl::Command should be placed in
the PowerSupplyControl::Command::* namespace and begin with a lowercase letter. Subclasses beginning with an uppercase letter should
be used for base classes that implement common logic but do not implement a complete command.

=head1 CONSTRUCTOR

=head2 new($config, $interface, $controller, @args)

Create a new command object with the specified properties.

Subclasses should ensure that they call the superclass constructor so that the base class is properly initialized.
Most often, it should be sufficient to leave this unimplemented and implement the initialize method instead.

=cut

sub new {
  my ($class, $config, $interface, $controller, @args) = @_;

  my $self = { controller => $controller
             , interface => $interface
             , args => \@args
             };

  bless $self, $class;

  my $merge = Hash::Merge->new('LEFT_PRECEDENT');
  $self->{config} = $merge->merge($config, $self->defaults);

  my @options = $self->options;
  push @options, 'debug=i';

  # psc.pl sets the require_order option to stop parsing options after the command name
  # We need to turn that off not so the comman can parse all of its options
  Getopt::Long::Configure('no_require_order');
  GetOptionsFromArray(\@args, $self, @options);

  $self->initialize;

  return $self;
}

=head1 STATUS OBJECT

The status object is a hash reference that contains the current state of the system. It is passed to all methods processing
methods for the command. The following keys are most commonly present in the status object, except as noted below.

=over

=item now

The current time in seconds since the start of the command.

=item voltage

The current voltage applied to the hotplate in volts. It is always present in timer events.

=item current

The current current drawn by the hotplate in amps. It is always present in timer events.

=item power

The current power output of the hotplate in watts. It is the product of voltage and current and should
generally be available whenever both of those are available.

=item resistance

The current resistance of the hotplate in ohms. It is the ratio of voltage over current and should
generally be available when both of those are available and current is non-zero.

=item temperature

The current temperature of the hotplate in degrees Celsius. This is derived from the resistance of the
hotplate and a mapping that describes the relationship between resistance and temperature. It should
usually be available whenever resistance is available, but may be inaccurate depending on the accuracy
of the mapping data available.

=item ambient

The current temperature of the ambient environment surrounding the hotplace in degrees Celsius. It is 
not always known with high accuracy and often drawn from static configuration data or possibly from user
prompts or external temperature sensors in some commands. Whatever the source, it is usually close
enough for most purpose at temperatures where solder reflow is concerned but its accuracy may present
problems at lower temperatures below 100 celsius.

=back

=cut


=head1 METHODS

Subclasses should only implement the methods that they need. If a particular feature or event type is
not used by a command, leave it unimplemented.

=head2 defaults

Return a hash of default configuration values for this command.

The default implementation returns an empty hash. Classes that require defaulting behaviour should override this method.

=cut

sub defaults {
  return {};
}

=head2 options

Return a list of options for Getopt::Long parsing of the command line arguments.

The default implementation returns an empty list. Classes that require options should override this method.

=cut

sub options {
  return;
} 

=head2 replaceFile($filename)

Open a file with a given filename. If a file with that name already exists, rename it first by appending a timestamp to the filename.

TODO: This should probably be moved to some utility module.

=over

=item $filename

The filename to open.

=item Return Value

A file handle to the opened file.

=back

=cut

sub replaceFile {
  my ($self, $filename) = @_;

  my $timestamp = timestamp();
  if (-f $filename) {
    rename $filename, "$filename." . $timestamp;
  }

  my $fh = IO::File->new($filename, 'w') || croak "Failed to open $filename: $!";
  if ($filename =~ /\.yaml$/) {
    $fh->print('# Generated by '. ref($self) .' at '. $timestamp ."\n");
  }
  return $fh;
}

=head2 writeHash($fh, $hash)

Write the contents of a flat hash to a file handle.

=cut

sub writeHash {
  my ($self, $fh, $hash, $echo) = @_;

  foreach my $key (sort keys %$hash) {
    print $fh "$key: $hash->{$key}\n";
    if ($echo) {
      $self->info("$echo: $key: $hash->{$key}");
    }
  }

  return $self;
}

=head2 initialize()

Initialize the command.

Implement this method in subclasses for commands that require any specific initialization logic during their creation.

This method should be used for initializing any internal state that is required for the command to run but
should not communicate with the power supply or any other external devices. Those should be done during the
preprocess method. This is useful for setting up internal state for unit tests without requiring any external
interactions during unit testing.

=cut

sub initialize {
  return;
}

=head2 preprocess($status)

Implement this method in subclasses for commands that require any specific pre-processing logic prior to the main event loop operation.

This method should be used for any non-timer related pre-processing. Unlike the initialize method, which is called during object
creation, this method is called after all necessary initialization of the command and other object and system state is complete.
It is also where any pre-event loop power supply or device communications should be done, such as ensuring that the power supply
is on and some current is flowing - if that's what will be needed during the event loop execution.

=cut

# Don't implement here. Implementing this method will cause data logging of preprocess events which is undesirable
# if the command does not process preprocess events.
#sub preprocess {
#  return;
#}

=head2 timerEvent($status)

Implement this method in subclasses for commands that require any specific timer event logic.

This method is called every time the timer event is triggered. Timer events should be careful to avoid blocking or
long running operations. Depending on the configuration, most of the time between timer events may be spent polling
and updating the hotplate status.

=cut

# Don't implement here. The framework will use ->can to determine if the command implements this method.
# Implementing this method will cause the creation of a timer watcher for this command, the data logging of
# timer events and the starting of the event loop, which is undesirable if the command does not process timer
# events.
#sub timerEvent {
#  return;
#}

=head2 keyEvent($status)

Implement this method in subclasses for commands that require any specific key event logic.

keyPress events are normally highly time-sensitive. Minimal logic should be implemented here such as updating
internal state to reflect the key press. This method should definitely avoid blocking or slow operations like
polling the hotplate status. If hotplate status is required, the keyPress event should update internal state
to reflect what key was pressed and when and then use interpolation either in the next timerEvent or in the
postprocess method.

This method is called every time a key is pressed, but only during the event loop and the event loop won't be
executed unless this command also implements the timerEvent method. The following additional keys are present
in the status object for keyEvents:

=over

=item key

The key that was pressed.

=back

=cut

# Don't implement here. The framework will use ->can to determine if the command implements this method.
# Implementing this method will cause the creation of an io watcher for this command and data logging of
# key events which is undesirable if the command does not process key events.
#sub keyEvent {
#  return;
#}

=head2 lineEvent($status)

Implement this method in subclasses for commands that require any specific line event logic. Will not work
without also defining the keyEvent method. The $status object will contain the following additional keys:

=over

=item line

The line of input from the user.

=back

=cut

sub lineEvent {  
  return;
}

=head2 postprocess($status, $history)

Implement this method in subclasses for commands that require any specific post-processing logic after the main event loop operation.

=over

=item status

The status object representing the final state of the system after the main event loop operation.

=item history

A reference to an array containing all of the status objects generated from preprocess until the end, in order. This includes the
status object passed to the postprocess method.

=back

=cut

# Don't implement here. Implementing this method will cause data logging of postprocess events which is undesirable
# if the command does not process postprocess events.
#sub postprocess {
#  return;
#}

=head2 prompt($prompt, default, @keys)

Prompt the user for a value.

=over

=item $prompt

The text prompt to display to the user.

TODO: This should probably be moved to some utility module.

=item $default

The default value to use if the user presses enter without typing anything.

=item Return Value

The value entered by the user, or the default value if nothing was entered. If the user presses enter without typing anything,
the default value will be returned.

=back

=cut

sub prompt {
  my ($self, $prompt, $default) = @_;

  print "$prompt ";
  print "[$default] " if defined $default;

  my $value = <STDIN>;
  chomp $value;
  $value =~ s/^\s+//;
  $value =~ s/\s+$//;

  if ($value eq '') {
    return $default;
  }

  return $value;
}

=head2 setLogger($logger)

Set the logger for the command.

=cut

sub setLogger {
  my ($self, $logger) = @_;
  $self->{logger} = $logger;
  $self->{logger}->addColumns(@{$self->{config}->{logging}->{columns}});
  $self->{logger}->debugLevel($self->{config}->{logging}->{'debug-level'} || 0);
}

sub startupCurrent {
  my ($self, $status) = @_;

  if (!defined $status->{current} || $status->{current} == 0) {
    my $interface = $self->{interface};
    my ($vmin, $vmax) = $interface->getVoltageLimits();
    $self->{interface}->setVoltage($self->{config}->{voltage}->{startup} || $vmin);
    sleep(2.0);
    $self->{interface}->poll($status);
    $self->{controller}->getTemperature($status);
    $self->{controller}->getAmbient($status);
  }
}

sub nobeep {
  my $self = shift;

  if (@_) {
    $self->{'no-beep'} = shift;
  } else {
    $self->{'no-beep'} = 1;
  }
}

=head2 beep

Beep the terminal.

=cut

sub beep {
  my ($self) = @_;

  return if $self->{'no-beep'};

  print "\a";
}

=head2 quitEvent($status)

Implement this method in subclasses that should handle a signal to terminate the process.
The event loop catches common signals including SIGINT, SIGQUIT and SIGTERM and will call
this method on the command if it is implemented.

=over

=item $status

The status object representing the current state of the system. The status object will
contain an element named 'signal' that contains the name of the signal that triggered this
event.

=item Return Value

If the method returns true, the event loop will not terminate. This can be used to
implement any graceful shutdown logic, such as turning on a cooling fan, writing out
any calibration data that was captured, etc.
If the method returns false, the event loop will terminate as soon as possible and the
postprocess method will *NOT* be called. If you wish to terminate and still call your
postprocess method, you can approximate this behaviour by calling:

    $self->{interface}->poll($status);
    $self->postprocess($status, $self->{'event-loop'}->getHistory());

=back

=cut

sub quitEvent {
  return;
}

=head2 setInfoChannel($channel)

Set the channel to use for informational messages.

=over

=item $channel

A reference to an object that implements a print method.
This allows for pluggable output channels for information to allow for future developments
like a GUI or web interface for these commands.

=back

=cut

sub setMessageOutputChannel {
  my ($self, $channel) = @_;
  $self->{'output-channel'} = $channel;
  return $self;
}

=head2 info($message)

Output an informational message to the user.

=over

=item $message

The message to be displayed to the user.

=item Return Value

Returns this command object to allow for method chaining.

=back

=cut

sub info {
  my ($self, $message) = @_;

  if (defined $self->{logger}) {
    $self->{logger}->info($message);
  }

  return $self;
}

=head2 debug($level, $message)

Output a debug message to the user.

=over

=item $level

A debug level number to indicate whether or not this message should be output.

=item $message

The message to be displayed to the user.

=item Return Value

Returns this command object to allow for method chaining.

=back

=cut

sub debug {
  my ($self, $level, $message) = @_;

  if (defined $self->{logger}) {
    $self->{logger}->debug($level, $message);
  }

  return $self;
}

sub warning {
  my ($self, $message) = @_;
  if (defined $self->{logger}) {
    $self->{logger}->warning($message);
  }
  return $self;
}

=head1 AUTHOR Brett Gersekowski

=cut

1;
